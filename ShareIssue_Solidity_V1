//This is the fisrt version of a decentralized share issuance with a multisig functionality.

//Name: Azam Razman
//Date: 24 Dec 2016
//Time: 17:09:11
//Version: v1

/*
Intro: This is a contract for a propiatary share issuance on the Ethereum network. In this smart contract, we aim to have fuctionality of:
1. Share issuance, including more issuance in the future, i.e. not one time only.
2. Multisig functionality, i.e. the issuer must be multiple entity, and need multiple private keys to have approval of share issuance.
3. Additionally, any decision on the contract must have signiture of multiple entity as well.
4. Only addresses approved will be able to recieve and send the tokens (only to other approved addresses).
... (and many more to come)
*/

//Inheritance allows a contract to acquire properties of a parent contract, without having to redefine all of them.
//Problem: This is single owned, not multi-owned... fixes expected in the future.
contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    //Problem: Unfimiliar syntex... not sure whether it should be onlyOwner or onlyOwner()
    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}

//Initialize contract.
contract ShareIssue is owned {

	//Initialize the name of the token (shares).
	string public shareName;

	//Initialize the symbol the share. To simplify, this is basically the ticker name.
	string public shareSymbol;

	/* This creates an array with all balances */
    mapping (address => uint256) public balanceOf;

    /* This generates a public event on the blockchain that will notify clients */
    //We can consider this as a "notification".
    event Transfer(address indexed from, address indexed to, uint256 value);

    //Initital share issue. Only to be invoked on an 
    function initialShareIssue(uint256 initialSupply, string initialName, string initialSymbol) {

        balanceOf[msg.sender] = initialSupply;
        initialName = initialName;
        shareSymbol = initialSymbol;
    }

    //Problem: We want to be able to create more shares in the future, however, the function below only cater to single central entity.
    function additionalShareIssue(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    /* This unnamed function is called whenever someone tries to send ether to it. */
    function () {
        throw;     // Prevents accidental sending of ether
    }
}
